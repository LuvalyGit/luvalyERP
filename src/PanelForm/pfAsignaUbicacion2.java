/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package PanelForm;

import Conexion.ExeSql;
import Dialogos.jdBuscaUbicacion;
import Formularios.fmMain;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import javax.swing.JOptionPane;
import javax.swing.JPasswordField;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.SwingConstants;

/**
 *
 * @author Marcelo Leiva
 */
public class pfAsignaUbicacion2 extends javax.swing.JPanel {
// Caché en RAM: Clave = SKU, Valor = Stock Real

    private HashMap<String, Double> stockCache = new HashMap<>();
    private String codigoOrigenSeleccionado = "";
    // Variables temporales para el flujo
    private String tempSku = "";
    private String tempNombre = "";
    private Double tempStockRef = 0.0;
    private boolean esAutomatico = false;
    // Lista para recordar qué SKUs fueron modificados manualmente
    private java.util.HashSet<String> manualEdits = new java.util.HashSet<>();

    // Modelo de la tabla para acceso rápido
    private DefaultTableModel modelo;

    /**
     * Creates new form pfAsignaUbicacion2
     */
    public pfAsignaUbicacion2() {
        initComponents();
        iniciarLogica();

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        btnBuscarOrigen = new javax.swing.JButton();
        txtUbicacionOrigen = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        txtSku = new javax.swing.JTextField();
        txtDestino = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        grilla = new javax.swing.JTable();
        jPanel2 = new javax.swing.JPanel();
        lblTotalItems = new javax.swing.JLabel();
        btnGuardar = new javax.swing.JButton();

        setLayout(new java.awt.BorderLayout());

        btnBuscarOrigen.setText("Ubicación");

        txtUbicacionOrigen.setEnabled(false);

        jLabel1.setText("SKU");

        jLabel2.setText("DESTINO");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(7, 7, 7)
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtSku))
                    .addComponent(txtUbicacionOrigen, javax.swing.GroupLayout.PREFERRED_SIZE, 254, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(btnBuscarOrigen, javax.swing.GroupLayout.PREFERRED_SIZE, 121, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtDestino, javax.swing.GroupLayout.PREFERRED_SIZE, 209, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(538, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(23, 23, 23)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnBuscarOrigen, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(txtUbicacionOrigen, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(txtSku, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2)
                    .addComponent(txtDestino, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(212, Short.MAX_VALUE))
        );

        add(jPanel1, java.awt.BorderLayout.NORTH);

        grilla.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "SKU", "Producto", "Cantidad", "Stock Ubicación", "Destino"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.Double.class, java.lang.Double.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, true, false, true
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane1.setViewportView(grilla);

        add(jScrollPane1, java.awt.BorderLayout.CENTER);

        lblTotalItems.setText("Total productos: 0");

        btnGuardar.setText("GUARDAR TODO");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap(440, Short.MAX_VALUE)
                .addComponent(lblTotalItems)
                .addGap(86, 86, 86)
                .addComponent(btnGuardar, javax.swing.GroupLayout.PREFERRED_SIZE, 147, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(298, 298, 298))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(31, 31, 31)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnGuardar, javax.swing.GroupLayout.PREFERRED_SIZE, 52, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lblTotalItems))
                .addContainerGap(46, Short.MAX_VALUE))
        );

        add(jPanel2, java.awt.BorderLayout.SOUTH);
    }// </editor-fold>//GEN-END:initComponents

    private void iniciarLogica() {
        modelo = (DefaultTableModel) grilla.getModel();

        // --- 1. Configurar Columna Oculta para el Código de Destino ---
        // Si el modelo solo tiene 5 columnas (las visuales), agregamos la 6ta
        if (modelo.getColumnCount() == 5) {
            modelo.addColumn("COD_OCULTO");
        }

        // Truco para ocultarla visualmente (Indice 5)
        grilla.getColumnModel().getColumn(5).setMinWidth(0);
        grilla.getColumnModel().getColumn(5).setMaxWidth(0);
        grilla.getColumnModel().getColumn(5).setWidth(0);
        grilla.getColumnModel().getColumn(5).setPreferredWidth(0);

        // A.Renderizador Normal(Para Texto: SKU, Nombre)
        DefaultTableCellRenderer renderTexto = new DefaultTableCellRenderer();
        renderTexto.setHorizontalAlignment(SwingConstants.CENTER);

        // B. Renderizador Inteligente (Para Números: Cantidad, Stock)
        DefaultTableCellRenderer renderNumeros = new DefaultTableCellRenderer() {
            @Override
            public java.awt.Component getTableCellRendererComponent(javax.swing.JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
                // Llamamos a la lógica base para que pinte colores, selección, etc.
                super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

                // SI ES UN NÚMERO, LO FORMATEAMOS
                if (value instanceof Double) {
                    double val = (Double) value;
                    // Si el número no tiene decimales (ej: 50.0)
                    if (val % 1 == 0) {
                        setText(String.valueOf((int) val)); // Muestra "50"
                    } else {
                        setText(String.valueOf(val));       // Muestra "50.5" si fuera el caso
                    }
                }

                setHorizontalAlignment(SwingConstants.CENTER);
                return this;
            }
        };

        // --- 2. Renderizadores (Estética) ---
        // APLICAR LOS RENDERIZADORES
        grilla.getColumnModel().getColumn(0).setCellRenderer(renderTexto);   // SKU
        grilla.getColumnModel().getColumn(2).setCellRenderer(renderNumeros); // Cantidad (Sin .0)
        grilla.getColumnModel().getColumn(3).setCellRenderer(renderNumeros); // Stock (Sin .0)

        // --- 3. Listeners (Sin cambios importantes aquí) ---
        btnBuscarOrigen.addActionListener(evt -> seleccionarOrigen());

        txtSku.addKeyListener(new KeyAdapter() {
            public void keyPressed(KeyEvent evt) {
                if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
                    procesarInputSku();
                }
            }
        });

        txtDestino.addKeyListener(new KeyAdapter() {
            public void keyPressed(KeyEvent evt) {
                if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
                    procesarInputDestino();
                }
            }
        });

        btnGuardar.addActionListener(evt -> guardarTodo());

        // --- ESPÍA DE CAMBIOS MANUALES (VERSIÓN MEMORIA) ---
        modelo.addTableModelListener(new javax.swing.event.TableModelListener() {
            @Override
            public void tableChanged(javax.swing.event.TableModelEvent e) {
                // Si es un UPDATE en la columna CANTIDAD (2)
                if (e.getType() == javax.swing.event.TableModelEvent.UPDATE && e.getColumn() == 2) {

                    // Si NO fue el sistema (fue el usuario)
                    if (!esAutomatico) {
                        try {
                            int row = e.getFirstRow();
                            String sku = modelo.getValueAt(row, 0).toString();

                            // ANOTAMOS EL SKU EN LA LISTA NEGRA
                            manualEdits.add(sku);

                            System.out.println(">> SKU marcado como manual: " + sku);

                        } catch (Exception ex) {
                            ex.printStackTrace();
                        }
                    }
                }
            }
        });

        txtSku.setEnabled(false);
        txtDestino.setEnabled(false);
    }

    // --- MÉTODOS INTERNOS ---
    private void seleccionarOrigen() {
        jdBuscaUbicacion dialog = new jdBuscaUbicacion(null, true);
        dialog.CargaBodegaOR(1);
        dialog.setVisible(true);

        String nombreUbicacion = dialog.GetNombreUbicacion();
        String codigoUbicacion = dialog.GetUbicacion(); // EJ: "BOD.01.01"

        if (nombreUbicacion != null && !nombreUbicacion.isEmpty()) {

            // 1. Guardamos el NOMBRE en la pantalla (Visual)
            txtUbicacionOrigen.setText(nombreUbicacion);

            // 2. Guardamos el CÓDIGO en la variable (Lógica)
            codigoOrigenSeleccionado = codigoUbicacion;

            // 3. Cargamos el caché usando el CÓDIGO
            cargarStockCache(codigoOrigenSeleccionado);

            txtSku.setEnabled(true);
            txtSku.requestFocus();

            modelo.setRowCount(0);
            lblTotalItems.setText("Total Items: 0");
        }
    }

    private void cargarStockCache(String codigoUbicacion) {
        stockCache.clear();
        ExeSql sql = new ExeSql();
        try {
            // Carga SKU y Cantidad de la ubicación seleccionada
            String qry = "SELECT sku, cant FROM mt_productos WHERE ubicacion = '" + codigoUbicacion + "' AND cant > 0";
            ResultSet rs = sql.Select(qry);
            while (rs.next()) {
                stockCache.put(rs.getString("sku").trim(), rs.getDouble("cant"));
            }
            System.out.println("Cache cargado: " + stockCache.size() + " productos.");
        } catch (SQLException ex) {
            fmMain.Mensaje("Error cargando stock: " + ex.getMessage());
        } finally {
            sql.Close();
        }
    }

    private void procesarInputSku() {
        String input = txtSku.getText().trim(); // Ya no hacemos toUpperCase forzado al inicio por si el codbar es numérico o sensible

        if (input.isEmpty()) {
            return;
        }

        String skuFinal = input.toUpperCase(); // Asumimos primero que es un SKU directo

        // --- LÓGICA NUEVA: SKU vs CÓDIGO DE BARRAS ---
        // 1. ¿Existe este input tal cual como SKU en la ubicación actual?
        if (!stockCache.containsKey(skuFinal)) {

            // Si NO es un SKU directo en esta ubicación, preguntamos si es un Código de Barras
            String skuTraducido = obtenerSkuPorCodigoBarra(input);

            if (skuTraducido != null) {
                // ¡Es un código de barras! Usamos el SKU que encontramos
                skuFinal = skuTraducido.trim().toUpperCase();

                // VALIDACIÓN CRÍTICA:
                // El código de barras existe en el sistema, PERO...
                // ¿El producto asociado (SKU) está físicamente en esta ubicación (stockCache)?
                if (!stockCache.containsKey(skuFinal)) {
                    Formularios.fmMain.Mensaje("El código " + input + " corresponde al SKU " + skuFinal + ", pero ese producto NO está en esta ubicación.");
                    txtSku.selectAll();
                    return;
                }

                // Si llegamos aquí, encontramos el producto vía código de barras y sí está en la ubicación.
                System.out.println("Escaneo traducido: " + input + " -> " + skuFinal);

            } else {
                // No es SKU en caché y tampoco es código de barras en BD
                Formularios.fmMain.Mensaje("El código/SKU " + input + " no existe en " + txtUbicacionOrigen.getText() + " ni en registro de barras.");
                txtSku.selectAll();
                return;
            }
        }

        // --- A PARTIR DE AQUÍ LA LÓGICA ES IGUAL (Usamos skuFinal) ---
        // 2. Buscar si ya existe en la grilla visual
        int filaExistente = buscarEnGrilla(skuFinal);

        if (filaExistente != -1) {
            // CASO A: YA EXISTE -> Sumar cantidad automáticamente
            double cantActual = Double.parseDouble(modelo.getValueAt(filaExistente, 2).toString());
            double stockMax = stockCache.get(skuFinal);

            if (cantActual + 1 <= stockMax) {
                modelo.setValueAt(cantActual + 1, filaExistente, 2);
                grilla.setRowSelectionInterval(filaExistente, filaExistente);
                txtSku.setText("");
                txtSku.requestFocus();
            } else {
                Formularios.fmMain.Mensaje("Stock insuficiente para SKU " + skuFinal + " (Max: " + stockMax + ")");
                txtSku.selectAll();
            }
        } else {
            // CASO B: NUEVO -> SIEMPRE PEDIR DESTINO
            tempSku = skuFinal;
            tempStockRef = stockCache.get(skuFinal);
            tempNombre = obtenerNombreProducto(skuFinal);

            // Mostramos feedback visual si fue traducido
            if (!input.equalsIgnoreCase(skuFinal)) {
                // Opcional: Mostrar en algún label que se leyó un código de barras
            }

            // Habilitar y saltar al campo Destino
            txtDestino.setEnabled(true);
            txtDestino.requestFocus();
        }
    }

    /**
     * Busca en la tabla CODBAR si el input corresponde a un código de barras.
     * Retorna el SKU asociado o NULL si no existe.
     */
    private String obtenerSkuPorCodigoBarra(String inputCodigo) {
        ExeSql sql = new ExeSql();
        String skuEncontrado = null;
        try {
            // Buscamos en la tabla que me mostraste en la imagen
            String qry = "SELECT sku FROM codbar WHERE codbar = '" + inputCodigo + "'";
            ResultSet rs = sql.Select(qry);
            if (rs.next()) {
                skuEncontrado = rs.getString("sku");
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            sql.Close();
        }
        return skuEncontrado;
    }

    private String obtenerNombreUbicacion(String codigo) {
        ExeSql sql = new ExeSql();
        String nombre = codigo; // Por defecto devolvemos el mismo código si falla
        try {
            // Ajusta "nombre" y "mt_codmetro" si tu tabla se llama diferente
            ResultSet rs = sql.Select("SELECT nombre FROM mt_codmetro WHERE codmetro = '" + codigo + "'");
            if (rs.next()) {
                nombre = rs.getString("nombre");
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            sql.Close();
        }
        return nombre;
    }

    private void procesarInputDestino() {
        String codigoDestino = txtDestino.getText().trim().toUpperCase();
        if (codigoDestino.isEmpty()) {
            return;
        }

        // 1. Validar que el código exista
        if (!validarDestinoBD(codigoDestino)) {
            fmMain.Mensaje("Ubicación de destino NO existe.");
            txtDestino.selectAll();
            return;
        }

        // 2. Obtener el nombre bonito para mostrar
        String nombreDestino = obtenerNombreUbicacion(codigoDestino);

        // 3. Agregar a la grilla (Pasamos ambos datos)
        agregarFila(tempSku, tempNombre, 1.0, tempStockRef, nombreDestino, codigoDestino);

        // 4. Resetear para el siguiente
        txtSku.setText("");
        txtSku.requestFocus();
        txtDestino.setText("");
        txtDestino.setEnabled(false);
    }

    // 
    private void agregarFila(String sku, String nombreProducto, Double cant, Double stock, String nombreDest, String codDest) {
        // Col 4: Nombre (Visible) | Col 5: Código (Oculto)
        modelo.addRow(new Object[]{sku, nombreProducto, cant, stock, nombreDest, codDest});

        lblTotalItems.setText("Total Items: " + modelo.getRowCount());
        grilla.scrollRectToVisible(grilla.getCellRect(grilla.getRowCount() - 1, 0, true));

        ajustarColumnas();
    }

    private int buscarEnGrilla(String sku) {
        // Busca si el SKU ya está en la tabla para sumar cantidad
        for (int i = 0; i < modelo.getRowCount(); i++) {
            String skuGrilla = modelo.getValueAt(i, 0).toString();
            if (skuGrilla.equals(sku)) {
                return i; // Encontrado
            }
        }
        return -1; // No encontrado
    }

    private String obtenerNombreProducto(String sku) {
        ExeSql sql = new ExeSql();
        String nom = "SIN NOMBRE";
        try {
            ResultSet rs = sql.Select("SELECT nombre FROM producto WHERE sku = '" + sku + "'");
            if (rs.next()) {
                nom = rs.getString("nombre");
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            sql.Close();
        }
        return nom;
    }

    private boolean validarDestinoBD(String ubi) {
        ExeSql sql = new ExeSql();
        boolean existe = false;
        try {
            ResultSet rs = sql.Select("SELECT 1 FROM mt_codmetro WHERE codmetro = '" + ubi + "'");
            if (rs.next()) {
                existe = true;
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            sql.Close();
        }
        return existe;
    }

    // --- GUARDADO MASIVO (BATCH) ---
    private void guardarTodo() {
        if (grilla.isEditing()) {
            grilla.getCellEditor().stopCellEditing();
        }
        if (modelo.getRowCount() == 0) {
            return;
        }

        // 1. Validar Stock Globalmente
        for (int i = 0; i < modelo.getRowCount(); i++) {
            Double cant = Double.parseDouble(modelo.getValueAt(i, 2).toString());
            Double stock = Double.parseDouble(modelo.getValueAt(i, 3).toString());
            if (cant > stock) {
                fmMain.Mensaje("Error Fila " + (i + 1) + ": Cantidad (" + cant + ") supera stock (" + stock + ")");
                return;
            }
        }

        // 2. Pedir Autorización (Obtenemos el NOMBRE del que autorizó)
        String usuarioAutoriza = solicitarAutorizacion();
        if (usuarioAutoriza == null) {
            return; // Si cancela, no hacemos nada
        }
        // 3. Ejecutar Transacción
        ExeSql sql = new ExeSql();
        try {
            sql.ExeSql("BEGIN;");

            String origen = codigoOrigenSeleccionado;
            String usuarioOperador = fmMain.GetUsuario(); // El que está sentado en el PC

            for (int i = 0; i < modelo.getRowCount(); i++) {
                String sku = modelo.getValueAt(i, 0).toString();
                double cant = Double.parseDouble(modelo.getValueAt(i, 2).toString());
                String destino = modelo.getValueAt(i, 5).toString(); // Código Oculto

                // --- A. MOVER PRODUCTO (Lógica de Stock) ---
                String qRestar = "UPDATE mt_productos SET cant = cant - " + cant
                        + ", fecha_mod = NOW(), usuario_mod = '" + usuarioOperador + "'"
                        + " WHERE ubicacion='" + origen + "' AND sku='" + sku + "'";
                sql.ExeSql(qRestar);

                // Lógica de Destino (Update o Insert)
                String qCheck = "SELECT 1 FROM mt_productos WHERE ubicacion='" + destino + "' AND sku='" + sku + "'";
                boolean existeDest = false;
                ResultSet rs = sql.Select(qCheck);
                if (rs.next()) {
                    existeDest = true;
                }

                if (existeDest) {
                    String qSumar = "UPDATE mt_productos SET cant = cant + " + cant
                            + ", fecha_mod = NOW(), usuario_mod = '" + usuarioOperador + "'"
                            + " WHERE ubicacion='" + destino + "' AND sku='" + sku + "'";
                    sql.ExeSql(qSumar);
                } else {
                    String qInsertar = "INSERT INTO mt_productos (ubicacion, sku, cant, usuario, fecha) "
                            + "VALUES ('" + destino + "', '" + sku + "', " + cant + ", '" + usuarioOperador + "', NOW())";
                    sql.ExeSql(qInsertar);
                }

                // --- B. GUARDAR EN BITÁCORA (Historial) ---
                // Aquí guardamos la "historia" de este movimiento específico
                // Verificamos si este producto fue tocado manualmente
                String notaManual = "";
                if (manualEdits.contains(sku)) {
                    notaManual = " [CANTIDAD EDITADA MANUALMENTE]";
                }

                // Construimos el mensaje final incluyendo la advertencia
                String detalleHistoria = "Traslado de " + cant + " unidades. Origen: " + origen
                        + " -> Destino: " + destino + notaManual;

                registrarEnBitacora(
                        usuarioOperador,
                        usuarioAutoriza,
                        "GUARDAR - UBICACION PRODUCTOS",
                        sku,
                        detalleHistoria, // <--- Aquí va el mensaje con la marca
                        sql
                );
            }

            sql.ExeSql("COMMIT;");
            fmMain.Mensaje("¡Movimiento exitoso y registrado en bitácora!");
            limpia_all();

        } catch (Exception e) {
            try {
                sql.ExeSql("ROLLBACK;");
            } catch (Exception ex) {
            }
            e.printStackTrace();
            fmMain.Mensaje("Error al guardar: " + e.getMessage());
        } finally {
            sql.Close();
        }
    }

    private String solicitarAutorizacion() {
        JPasswordField pf = new JPasswordField();
        int ok = JOptionPane.showConfirmDialog(this, pf, "Ingrese Código Autorización", JOptionPane.OK_CANCEL_OPTION);

        if (ok == JOptionPane.OK_OPTION) {
            String pass = new String(pf.getPassword()).trim();
            if (pass.isEmpty()) {
                return null;
            }

            ExeSql sql = new ExeSql();
            try {
                // Buscamos el nombre del usuario dueño del código
                ResultSet rs = sql.Select("SELECT usuario FROM auth_productos WHERE codigo = '" + pass + "'");
                if (rs.next()) {
                    return rs.getString("usuario"); // ¡Éxito! Retorna "JUAN.PEREZ"
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                sql.Close();
            }

            fmMain.Mensaje("Código incorrecto.");
        }
        return null; // Canceló o falló
    }

    /**
     * Método público para limpiar todo desde fmMain
     */
    public void limpia_all() {
        // 1. Limpiar la tabla
        if (modelo != null) {
            modelo.setRowCount(0);
        }

        // 2. Limpiar campos de texto
        txtUbicacionOrigen.setText("");
        txtSku.setText("");
        txtDestino.setText("");

        // 3. Bloquear inputs hasta que elijan origen de nuevo
        txtSku.setEnabled(false);
        txtDestino.setEnabled(false);

        // 4. Resetear contadores y memoria
        stockCache.clear();
        lblTotalItems.setText("Total Items: 0");

        // 5. Limpiar variables temporales
        tempSku = "";
        tempNombre = "";
        tempStockRef = 0.0;
        manualEdits.clear();
    }

    /**
     * Método Universal para guardar en la bitácora. CORREGIDO: Maneja la
     * excepción SQLException.
     */
    private void registrarEnBitacora(String operario, String autorizador, String accion,
            String referencia, String detalle, ExeSql sqlObj) {

        try {
            // Manejo de escalabilidad: Si el módulo no requiere autorización, llega null
            String autorizaSql = (autorizador == null || autorizador.isEmpty()) ? "NULL" : "'" + autorizador + "'";

            String qry = "INSERT INTO sistema_bitacora "
                    + "(fecha, modulo, accion, usuario_operador, usuario_autoriza, referencia_id, detalle) "
                    + "VALUES (NOW(), 'UBICACION DE PRODUCTOS', '" + accion + "', '"
                    + operario + "', " + autorizaSql + ", '" + referencia + "', '" + detalle + "')";

            // Usamos el objeto SQL que ya trae la transacción abierta
            sqlObj.ExeSql(qry);

        } catch (SQLException ex) {
            // Si falla el log, imprimimos el error pero NO detenemos la transacción principal
            // (Opcional: podrías lanzar una RuntimeException si prefieres que falle todo)
            System.err.println("Error al escribir en bitácora: " + ex.getMessage());
            ex.printStackTrace();
        }
    }

    /**
     * Ajusta el ancho de las columnas según el contenido (texto) de las celdas
     * y la cabecera.
     */
    private void ajustarColumnas() {
        // Recorremos todas las columnas visibles
        for (int column = 0; column < grilla.getColumnCount(); column++) {

            // OJO: Saltamos la columna oculta (índice 5) para que NO se abra
            if (column == 5) {
                continue;
            }

            javax.swing.table.TableColumn tableColumn = grilla.getColumnModel().getColumn(column);
            int preferredWidth = tableColumn.getMinWidth();
            int maxWidth = tableColumn.getMaxWidth();

            // 1. Calcular ancho del TÍTULO (Cabecera)
            javax.swing.table.TableCellRenderer headerRenderer = grilla.getTableHeader().getDefaultRenderer();
            java.awt.Component headerComp = headerRenderer.getTableCellRendererComponent(grilla, tableColumn.getHeaderValue(), false, false, 0, column);
            preferredWidth = Math.max(preferredWidth, headerComp.getPreferredSize().width);

            // 2. Calcular ancho del CONTENIDO (Filas)
            // (Revisamos todas las filas para encontrar la celda más ancha)
            for (int row = 0; row < grilla.getRowCount(); row++) {
                javax.swing.table.TableCellRenderer cellRenderer = grilla.getCellRenderer(row, column);
                java.awt.Component c = grilla.prepareRenderer(cellRenderer, row, column);
                int width = c.getPreferredSize().width + grilla.getIntercellSpacing().width;
                preferredWidth = Math.max(preferredWidth, width);
            }

            // 3. Aplicar el ancho con un pequeño margen (Padding) de 15 píxeles
            tableColumn.setPreferredWidth(preferredWidth + 15);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnBuscarOrigen;
    private javax.swing.JButton btnGuardar;
    private javax.swing.JTable grilla;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lblTotalItems;
    private javax.swing.JTextField txtDestino;
    private javax.swing.JTextField txtSku;
    private javax.swing.JTextField txtUbicacionOrigen;
    // End of variables declaration//GEN-END:variables
}
